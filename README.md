# MOON
#### Video Demo:  <https://youtu.be/kpReOvncbJk>
#### Description: Moon is a board game for two players. The project is the implementation in python of the game using the pygame library.

## Introduction
This is my CS50 final project. It has been a great course and I've learned so much in a little time. This project is one of the few I've been giving time. It is not fundamentally complex and it's written in only one langage but I surely wouldn't have been able to write it, had I not taken CS50, and it has also been a good way to gain knowledge on a few topics:
- classes and properties
- module importation
- the PIL and pygame libraries
etc.
I'm happy to share it with CS50 learners/ex-learners and hope it will give a distraction between two pb sets !
There are many ways to improve this project and I'd gladly receive any feedback. Here are a few functions I'd like to add : online play, memory of the previous games... and also (as meanwhile I took CS50AI), an AI that can play the game. Any help on those matters would be appreciated. Hope to read from you, reader!

## I. Moon : the gamerules
Moon is a board game where two players (white and black) play successively. Each player has a stock of six tokens and must align four tokens to win. Three types of alignments are possible: on the outer circle, on the inner circle, or on one of the straight lines.

The game is played in two successives phases that have different rules.
### First phase
During the first phase, each player puts a token on an empty case, white starting. If at any time, a player aligns 4 tokens, he/she wins. The first phase ends when both players have placed all of their tokens.
### Second phase
During this phase, each player has now three choices :
- to move a token from its space to another one that is directly connected by a line and empty ;

![move explanation 1](/contents/expl_move1.png)

- to jump over a token belonging to the opponent : then the token of the player arrives on the consecutive space, the oppponent gets his/her token back and will be able to place it on an empty space at his/her turn ;

![move explanation 2](/contents/expl_move2.png)

- to jump over a token of his/her own : then the player chooses to remove it or not ; if the jumped over token is removed, the player can play it later on an empty space ;

![move explanation 3](/contents/expl_move3.png)

And as in first phase, if a player aligns four tokens, the game ends !

## II. Underneath the hood : the Moon class
To let the game work, the programs rests on the following files/directories:
- Moon.py : this file contains a helper function that computes the coordinates of the neighbors of a given space on the board and the implementations of the Moon class. I will only detail next the Moon class as it is essential for the game : it gives a representation of the states of the game and of their transitions.
- Moon_game.py : this file relies on the Moon class and on the pygame library to implement an interface to play the game.
- Moon_draw.py : this is a helper program for future research that gives a visual representation of the state of the game as a 50x50 bit map.
- contents/ : the directory with the graphical elements used in Moon_game.py
- repertoire/ : the directory where the bmp generated by Moon_draw.py are registered; it is automatically created by a call to the print_and_register() function

### The Moon class: parameters
The class Moon implements a game. It has the following parameters:
- initial : the state in which you want to start the game. It is the content of the board as white play. It should be described as a list of two lists : the first list being the seven spaces on the outer circle, the second list being the seven spaces in the inner circle. Each list contains seven elements that must take values in {0 (empty space), 1 (white token), -1 (black token)} The default is [[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]] (all empty spaces).
This schema shows how the indexes used in the initial state lists match the positions on the graphical board :

![picture of the board with the indexes at the matching locations](/contents/indexes.png)

- has_gone_to_phase_2 (default:False): the class automatically computes the phase in wich the game is by comparing the numbers of white and black tokens. If one wants to initiate the class with a board that could be a First phase board (those are the boards where the number of white and black are equal or where there is exactly one more white) but precise that it happens in the second phase, one must assign True to this parameter.

### The Moon class : attributes
- .state registers the state of the board, ie. where the tokens that have been played are placed
- .player gives the player whose turn it is: 1 for white, -1 for black
- .nb_{b or w} registers the number of tokens the {b or w} player has still left to place on the board
- .winner : None if the Game has not been won yet, 1 if white won, -1 if black won

### The Moon class : functions and properties
- \__repr__() : allows to print a synthese of the infos of the game : state, player, phase and winner.
- The .phase() of the game (1 or 2) is computed from the number of tokens the player have still yet to play. If those numbers equal or if there's only one more white, the game is in Phase 1 (except if the class has been initiated with gone_to_phase_2 = True). In any other case, it's in Phase 2.
- .rmn and .other_rmn properties give the value of the numbers of remaining tokens of the current player and of its opponent
- .other_player(), .switch_player(), .p1_available_actions() and .p2_available_actions() are helper functions
- .is_won() returns a Boolean
- .play(self, action, phase) plays the given action in the adapted phase. If this results in a player winning, the winner is registered in the attribute .winner
- .play_random() chooses a possible action in the actual phase and state and plays it. It detects if the game needs to go from phase 1 to phase 2 and registers it by setting the attribute .has_gone_to_phase_2 to True.

## III. The game display and interface
Using the pygame library, it's possible to display a window allowing the user to display a interactive screen to play the game. This is done in the Moon_game.py program. It's based on five infinite loops:
### 1. The welcome loop
This renders the welcome screen ; when the users mouse hovers over the "Play" button, it's highlighted and whenever the user clicks on it, a game loop begins.
### 2. The game loop
The game displays the informations as follows:

![display of the Moon_game in the game loop](/contents/expl_board.png)

The possible positions to click on (to place or to move a token, depending on the phase of the game) are highlighted whenever the users mouse hovers over it. A "Random play" button is also in service that plays automatically a randomly chosen move adapted to the state of the game.
### 3. The choice loop
When the user has chosen a token to move (in phase 2), it's marked as selected with blue stripes (see following image). The user must then choose a destination and the possible positions to click on are again highlighted when hovered on. If the user clicks on a suited position, the move is played and we're back in the game loop. But it can happen that the choice leaves some ambiguity :

#### A. When the user must decide to capture its own token or not:
![choice explanation 1](/contents/expl_choice1.png)

#### B. When there are two possible ways to arrive at the same destination, one involving capturing an opponent token and the other one avoiding it:
![choice explanation 2](/contents/expl_choice2.png)

Then a fourth loop is created waiting for the second choice.

If the user clicks on a non possible zone, the token is deselected and we're back in the game loop.

### 4. The 2nd choice loop
The user must decide between two alternatives. The screen is divided into two rectangles of the same size, each displaying the description of an alternative. A click on a given zone (left or right) chooses the corresponding alternative.

Here are the descriptions for the alternatives :
#### Choice A :
- "I want it back !" : the user decides to retreive the jumped over token.
- "Leave it here..." : the user decides to leave it where it is.

#### Choice B :
- "Take that back !" : the user decides to capture the opponent token.
- "I come in peace." : the user takes the other way, avoiding the opponent.

### 5. The game over loop
When the game is won, the name of the winner is printed on the last played board. A "Play" button is displayed, that links to a new game loop.
